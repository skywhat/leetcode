#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>

using namespace std;

class Solution {
public:
    int find(vector<int>& uf, int id) {
        while (uf[id] != id) {
            uf[id] = uf[uf[id]]; // path compression
            id = uf[id];
        }

        return id;
    }

    vector<int> repair_machine(vector<vector<int>> network,
                               vector<int> initial_machines) {
        int size = network.size();
        vector<int> uf(size, 0);
        for (int i = 0; i < size; ++i) {
            uf[i] = i;
        }
        // divide into different sets via union find
        for (int i = 0; i < size; ++i) {
            for (int j = 0; j < i; ++j) {
                if (network[i][j]) {
                    int v1 = find(uf, i);
                    int v2 = find(uf, j);
                    if (v1 != v2) {
                        uf[v1] = v2;
                    }
                }
            }
        }

        unordered_set<int> initials(initial_machines.begin(),
                                    initial_machines.end());
        unordered_map<int, unordered_set<int>> sets;
        vector<int> res = {0, 0};
        for (int i = 0; i < size; ++i) {
            sets[find(uf, i)].insert(i);
        }

        for (auto&& subsets : sets) {
            int cnt = 0;
            int infected_pc = size;
            for (auto&& id : subsets.second) {
                if (initials.count(id)) {
                    infected_pc = min(id, infected_pc);
                    cnt++;
                }
            }

            if (cnt == 1 && res[1] <= (int)subsets.second.size()) {

                if (res[1] == (int)subsets.second.size()) {
                    res[0] = min(infected_pc, res[0]);
                } else {
                    res[0] = infected_pc;
                    res[1] = subsets.second.size();
                }
            }
        }

        return res;
    }
};

int main() {
    vector<vector<int>> network
        = {
            {1, 0, 0, 0, 0, 0, 0},
            {1, 1, 0, 0, 0, 0, 0},
            {0, 0, 1, 0, 0, 0, 0},
            {0, 0, 1, 1, 0, 0, 0},
            {0, 0, 1, 0, 1, 0, 0},
            {0, 0, 0, 0, 0, 1, 0},
            {0, 0, 0, 1, 0, 0, 1}
        };
    vector<int> initial_machines = {1, 2, 6};

    Solution s;
    vector<int> res = s.repair_machine(network, initial_machines);

    cout << "["<<res[0] <<", "<< res[1]<<"]" << endl;

    return 0;
}
